#--coding:utf8 --

try:
    import configparser
except:
    import ConfigParser as configparser

import os
import stat
import ssr.utils
import json
import ssr.vars
import ssr.configuration
# import rpm
import ssr.log

VULNERABILITY_INI_FILEPATH = ssr.vars.SSR_PLUGIN_PYTHON_ROOT_DIR + "/ssr/config/vulnerability-scan.ini"
INVALID_RPMS_KEY = "invalid_rpms"
# SCAN_RESULT_PATH = "/usr/share/ks-ssr-manager/ssr-config-vulnerability.txt"
FILE_GROUP_VULNERABILITY = "Vulnerability"
# FPK: File vulnerability Key
FPK_MODE_FILE_LIST = "PackageList"

# if len(ssr.utils.subprocess_has_output("cat  /etc/.kyinfo  | grep 'milestone = 3.3'")) != 0:
OPENSSH_CHECK_VERSION = "8.5p1"
OPENSSL_CHECK_VERSION = "1.1.1g"
if len(ssr.utils.subprocess_has_output("cat  /etc/.kyinfo  | grep 'milestone = 3.3'")) != 0:
    SUDO_CHECK_VERSION = "1.9.5p2"
elif len(ssr.utils.subprocess_has_output("cat  /etc/.kyinfo  | grep 'milestone = 3.2'")) != 0:
    SUDO_CHECK_VERSION = "1.8.6p3"
else:
    SUDO_CHECK_VERSION = ""
NTP_CHECK_VERSION = "4.2.8p13"
if len(ssr.utils.subprocess_has_output("cat  /etc/.kyinfo  | grep 'milestone = 3.2'")) != 0:
    BASH_CHECK_VERSION = "4.4.30"
else:
    BASH_CHECK_VERSION = ""

if len(ssr.utils.subprocess_has_output("cat  /etc/.kyinfo  | grep 'milestone = 3.2'")) != 0:
    POLKIT_CHECK_VERSION = "0.96-11"
elif len(ssr.utils.subprocess_has_output("cat  /etc/.kyinfo  | grep 'milestone = 3.3'")) != 0:
    POLKIT_CHECK_VERSION = "0.112-26"
elif len(ssr.utils.subprocess_has_output("cat  /etc/.kyinfo  | grep 'milestone = 3.4-1'")) != 0:
    POLKIT_CHECK_VERSION = "0.115-11"
else:
    POLKIT_CHECK_VERSION = ""
        

CHECK_RPM_VERSION_CMD = 'function version_ge() { test "$(echo "$@" | tr " " "\n" | sort -rV | head -n 1)" == "$1"; }'
CUT_RPM_VERSION_CMD = 'rpm -q --qf "%{Version}\n"'
CUT_RPM_RELEASE_CMD = 'rpm -q --qf "%{Release}\n"'

class VulnerabilityScan:
    def __init__(self):
        self.conf = configparser.ConfigParser()
        self.conf.read(VULNERABILITY_INI_FILEPATH)
        self.rpm_version = ""
        self.is_scan = False
        try:
            self.mode_filelist = self.conf.get(FILE_GROUP_VULNERABILITY, FPK_MODE_FILE_LIST).split(';')
        except Exception as e:
            self.mode_filelist = list()
            ssr.log.debug(str(e))

    def check_package_version(self, package_name):
        ssr.log.debug("check rpm version : ")
        if package_name == "openssh" and OPENSSH_CHECK_VERSION != "":
            self.rpm_version = str(ssr.utils.subprocess_has_output("{0} {1}".format(CUT_RPM_VERSION_CMD,package_name)))
            result = int(ssr.utils.subprocess_has_output("{0};  if version_ge {1} {2}; then echo 1; else echo -1; fi".format(CHECK_RPM_VERSION_CMD,self.rpm_version,OPENSSH_CHECK_VERSION)))
            ssr.log.debug(str(OPENSSH_CHECK_VERSION))
        elif package_name == "openssl" and OPENSSL_CHECK_VERSION != "":
            self.rpm_version = str(ssr.utils.subprocess_has_output("{0} {1}".format(CUT_RPM_VERSION_CMD,package_name)))
            result = int(ssr.utils.subprocess_has_output("{0};  if version_ge {1} {2}; then echo 1; else echo -1; fi".format(CHECK_RPM_VERSION_CMD,self.rpm_version,OPENSSL_CHECK_VERSION)))
            ssr.log.debug(str(OPENSSL_CHECK_VERSION))
        elif package_name == "sudo" and SUDO_CHECK_VERSION != "":
            self.rpm_version = str(ssr.utils.subprocess_has_output("{0} {1}".format(CUT_RPM_VERSION_CMD,package_name)))
            result = int(ssr.utils.subprocess_has_output("{0};  if version_ge {1} {2}; then echo 1; else echo -1; fi".format(CHECK_RPM_VERSION_CMD,self.rpm_version,SUDO_CHECK_VERSION)))
            ssr.log.debug(str(SUDO_CHECK_VERSION))
        elif package_name == "ntp" and NTP_CHECK_VERSION != "":
            self.rpm_version = str(ssr.utils.subprocess_has_output("{0} {1}".format(CUT_RPM_VERSION_CMD,package_name)))
            result = int(ssr.utils.subprocess_has_output("{0};  if version_ge {1} {2}; then echo 1; else echo -1; fi".format(CHECK_RPM_VERSION_CMD,self.rpm_version,NTP_CHECK_VERSION)))
            ssr.log.debug(str(NTP_CHECK_VERSION))
        elif package_name == "bash" and BASH_CHECK_VERSION != "":
            self.rpm_version = str(ssr.utils.subprocess_has_output("{0} {1}".format(CUT_RPM_VERSION_CMD,package_name)))
            result = int(ssr.utils.subprocess_has_output("{0};  if version_ge {1} {2}; then echo 1; else echo -1; fi".format(CHECK_RPM_VERSION_CMD,self.rpm_version,BASH_CHECK_VERSION)))
            ssr.log.debug(str(BASH_CHECK_VERSION))
        elif package_name == "polkit" and POLKIT_CHECK_VERSION != "":
            release = str(ssr.utils.subprocess_has_output("{0} {1}".format(CUT_RPM_RELEASE_CMD,package_name)))
            self.rpm_version = str(ssr.utils.subprocess_has_output("{0} {1}".format(CUT_RPM_VERSION_CMD,package_name))) + "-" + release.split('.')[0]
            result = int(ssr.utils.subprocess_has_output("{0};  if version_ge {1} {2}; then echo 1; else echo -1; fi".format(CHECK_RPM_VERSION_CMD,self.rpm_version,POLKIT_CHECK_VERSION)))
            ssr.log.debug(str(POLKIT_CHECK_VERSION))
        else:
            result = 0

        return result

    def get(self):
        retdata = dict()
        retdata["enabled"] = False
        
        # 文件扫描返回结果给前台
        invalid_rpms = ""

        if self.is_scan:
            for mode_file in self.mode_filelist:
                ssr.log.debug(str(mode_file))
                # if self.check_package_version(str(mode_file)) == "1" or self.check_package_version(str(mode_file)) == "0":
                if int(self.check_package_version(mode_file)) >= 0:
                    continue
                else:
                    invalid_rpms += mode_file + " " + self.rpm_version + ";"

        ssr.log.debug(str(invalid_rpms))
        if invalid_rpms == "":
            retdata[INVALID_RPMS_KEY] = ";"
        else:
            retdata[INVALID_RPMS_KEY] = invalid_rpms

        return (True, json.dumps(retdata))

    def set(self, args_json):
        args = json.loads(args_json)

        if args["enabled"]:
            self.is_scan = True
        else:
            self.is_scan = False

        return (True, '')

